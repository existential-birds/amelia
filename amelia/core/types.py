"""Configuration and shared type definitions for the Amelia orchestrator.

Contains StrEnum types (DriverType, TrackerType, Severity) and
Pydantic models (RetryConfig, Profile, Settings, Issue) used throughout
the Amelia agentic coding orchestrator.
"""
from datetime import datetime
from enum import StrEnum
from pathlib import Path
from typing import Any, Literal

from pydantic import BaseModel, ConfigDict, Field


class DriverType(StrEnum):
    """LLM driver type for agent configuration."""

    CLI = "cli"
    API = "api"


class TrackerType(StrEnum):
    """Issue tracker type for profile configuration."""

    JIRA = "jira"
    GITHUB = "github"
    NOOP = "noop"


class AgentConfig(BaseModel):
    """Per-agent driver and model configuration.

    Attributes:
        driver: LLM driver type ('api' or 'cli').
        model: LLM model identifier.
        options: Agent-specific options (e.g., max_iterations).
    """

    model_config = ConfigDict(frozen=True)

    driver: DriverType
    model: str
    options: dict[str, Any] = Field(default_factory=dict)


class RetryConfig(BaseModel):
    """Retry configuration for transient failures.

    Attributes:
        max_retries: Maximum number of retry attempts (0-10).
        base_delay: Base delay in seconds for exponential backoff (0.1-30.0).
        max_delay: Maximum delay cap in seconds (1.0-300.0).
    """

    max_retries: int = Field(
        default=3, ge=0, le=10, description="Maximum number of retry attempts"
    )
    base_delay: float = Field(
        default=1.0, ge=0.1, le=30.0, description="Base delay in seconds for exponential backoff"
    )
    max_delay: float = Field(
        default=60.0, ge=1.0, le=300.0, description="Maximum delay cap in seconds"
    )


class Profile(BaseModel):
    """Configuration profile for Amelia execution.

    This model is frozen (immutable) to support the stateless reducer pattern.
    Use model_copy(update={...}) to create modified copies.

    Attributes:
        name: Profile name (e.g., 'work', 'personal').
        tracker: Issue tracker type (jira, github, noop).
        working_dir: Working directory for agentic execution.
        plan_output_dir: Directory for saving implementation plans.
        plan_path_pattern: Path pattern for plan files with {date} and {issue_key} placeholders.
        retry: Retry configuration for transient failures.
        agents: Per-agent driver and model configuration.
    """

    model_config = ConfigDict(frozen=True)

    name: str
    tracker: TrackerType = TrackerType.NOOP
    working_dir: str
    plan_output_dir: str = "docs/plans"
    plan_path_pattern: str = "docs/plans/{date}-{issue_key}.md"
    retry: RetryConfig = Field(default_factory=RetryConfig)
    agents: dict[str, AgentConfig] = Field(default_factory=dict)

    def get_agent_config(self, agent_name: str) -> AgentConfig:
        """Get config for an agent.

        Args:
            agent_name: Name of the agent (e.g., 'architect', 'developer').

        Returns:
            AgentConfig for the specified agent.

        Raises:
            ValueError: If agent not configured in this profile.
        """
        if agent_name not in self.agents:
            raise ValueError(f"Agent '{agent_name}' not configured in profile '{self.name}'")
        return self.agents[agent_name]


class Settings(BaseModel):
    """Global settings for Amelia.

    Attributes:
        active_profile: Name of the currently active profile.
        profiles: Dictionary mapping profile names to Profile objects.
    """
    active_profile: str
    profiles: dict[str, Profile]

class Issue(BaseModel):
    """Issue or ticket to be worked on.

    Attributes:
        id: Unique issue identifier (e.g., 'JIRA-123', 'GH-456').
        title: Issue title or summary.
        description: Detailed issue description.
        status: Current issue status (default: 'open').
    """
    id: str
    title: str
    description: str
    status: str = "open"


class Design(BaseModel):
    """Design document for implementation.

    Can be user-provided via import or generated by a future Brainstorming pipeline.

    Attributes:
        content: The markdown content of the design document.
        source: Where the design came from ("import", "brainstorming", "file").
    """

    content: str
    source: str = "import"

    @classmethod
    def from_file(cls, path: Path | str) -> "Design":
        """Load design from markdown file."""
        content = Path(path).read_text(encoding="utf-8")
        return cls(content=content, source="file")


class Severity(StrEnum):
    """Severity level for review results.

    Uses standard code review terminology:
    - CRITICAL: Blocking issues that must be fixed
    - MAJOR: Should fix before merging
    - MINOR: Nice to have, suggestions
    - NONE: No issues found
    """

    CRITICAL = "critical"
    MAJOR = "major"
    MINOR = "minor"
    NONE = "none"


class ReviewResult(BaseModel):
    """Result from a code review.

    Attributes:
        reviewer_persona: The persona or role of the reviewer.
        approved: Whether the review approved the changes.
        comments: List of actionable issues to fix. Filtered at creation time
            to exclude positive observations.
        severity: Severity level of issues found (none, minor, major, critical).
    """

    model_config = ConfigDict(frozen=True)

    reviewer_persona: str
    approved: bool
    comments: list[str]
    severity: Severity


class OracleConsultation(BaseModel):
    """Record of an Oracle consultation for persistence and analytics.

    Attributes:
        timestamp: When the consultation occurred.
        problem: The problem statement submitted.
        advice: The Oracle's advice (None until complete).
        model: LLM model used.
        session_id: UUIDv4, generated per-consultation by Oracle.consult().
        workflow_id: Optional workflow ID for cross-referencing with orchestrator runs.
        tokens: Token counts (e.g., {"input": N, "output": M}).
        cost_usd: Estimated cost in USD.
        files_consulted: File paths included in context.
        outcome: Whether consultation succeeded or errored.
        error_message: Error details if outcome is "error".
    """

    timestamp: datetime
    problem: str
    advice: str | None = None
    model: str
    session_id: str
    workflow_id: str | None = None
    tokens: dict[str, int] = Field(default_factory=dict)
    cost_usd: float | None = None
    files_consulted: list[str] = Field(default_factory=list)
    outcome: Literal["success", "error"] = "success"
    error_message: str | None = None
